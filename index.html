<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>С Днем Рождения!</title>
    <style>
        html, body { margin: 0; padding: 0; overflow: hidden; background: #000; height: 100vh; font-family: Arial, sans-serif; }
        canvas { display: block; }

        #startScreen {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: #000;
            display: flex; justify-content: center; align-items: center; flex-direction: column;
            z-index: 10; color: #fff;
        }
        button {
            padding: 15px 30px; font-size: 24px;
            background: linear-gradient(45deg, #FF5733, #FFC300);
            border: none; color: white; border-radius: 50px; cursor: pointer;
            box-shadow: 0 0 20px rgba(255, 165, 0, 0.5); transition: transform 0.2s;
        }
        button:hover { transform: scale(1.1); }
        button:disabled { background: #555; cursor: wait; box-shadow: none; transform: none; }

        #endMessage {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            color: #fff; font-size: 40px; opacity: 0; pointer-events: none;
            transition: opacity 3s ease-in; text-align: center;
            z-index: 20; text-shadow: 0 0 20px #FFD700; width: 100%;
        }

        #finalVideo {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            object-fit: contain; display: none; z-index: 30; background: #000;
        }

        #errorLog {
            position: absolute; bottom: 0; left: 0; width: 100%; background: rgba(255,0,0,0.8);
            color: white; padding: 10px; font-size: 12px; display: none; z-index: 100;
        }
    </style>
</head>
<body>

<audio id="bgMusic" preload="auto"></audio>

<video id="finalVideo" controls playsinline preload="auto">
    <source src="video.mp4" type="video/mp4">
</video>

<div id="startScreen">
    <h1>Для тебя есть сюрприз...</h1>
    <br>
    <button id="startBtn" onclick="startCelebration()">Открыть поздравление</button>
</div>

<div id="endMessage">❤️ С Днем Рождения! ❤️</div>
<div id="errorLog"></div>

<canvas id="mainCanvas"></canvas>

<script>
window.onerror = function(msg, url, line) {
    const log = document.getElementById('errorLog');
    log.style.display = 'block';
    log.innerHTML += `Ошибка: ${msg} (строка ${line})<br>`;
    return false;
};

// =========================================================
// === 1. МУЗЫКА ===
const musicPlaylist = ["music1.mp3", "music2.mp3", "music3.mp3"];

// === 2. ФОТО И ПОДПИСИ ===
const cloudContent = [
    { src: "мем1.jpg", text: "от Азизика" },
    { src: "мем2.jpg", text: "от Азизика" },
    { src: "мем4.jpg", text: "от Азизика" },
    { src: "мем5.jpg", text: "от Азизика" },
    { src: "мем6.jpg", text: "от Азизика" },
    { src: "мем7.jpg", text: "от Азизика" },
    { src: "мем8.jpg", text: "от Азизика" },
    { src: "мем1Соня.jpg", text: "от Сонюшки" },
    { src: "мем2Соня.jpg", text: "от Сонюшки" },
    { src: "мем3Соня.jpg", text: "от Сонюшки" },
    { src: "мем4Соня.jpg", text: "от Сонюшки" },
    { src: "мем5Соня.jpg", text: "от Сонюшки" },
    { src: "мем6Соня.jpg", text: "от Сонюшки" },
    { src: "мем7Соня.jpg", text: "от Сонюшки" },
    { src: "мем8Соня.jpg", text: "от Сонюшки" },
    { src: "мем9Соня.jpg", text: "от Сонюшки" },
    { src: "мем10Соня.jpg", text: "от Сонюшки" },
    { src: "мем13Соня.jpg", text: "от Сонюшки" },
    { src: "мем2Кир.jpg", text: "от Зайчика" },
    { src: "мем3Кир.jpg", text: "от Зайчика" },
    { src: "мем4Кир.jpg", text: "от Зайчика" },
    { src: "мем5Кир.jpg", text: "от Зайчика" },
    { src: "мем1Саша.jpg", text: "от Сашки" },
    { src: "мем2Саша.jpg", text: "от Сашки" },
    { src: "мем3Саша.jpg", text: "от Сашки" },
    { src: "мем4Саша.jpg", text: "от Сашки" },
    { src: "мем5Саша.jpg", text: "от Сашки" },
    { src: "мем6Саша.jpg", text: "от Сашки" },
    { src: "мем7Саша.jpg", text: "от Сашки" },
    { src: "мем1Дар.jpg", text: "от Дариши" },
    { src: "мем2Дар.jpg", text: "от Дариши" },
    { src: "мем3Дар.jpg", text: "от Дариши" },
    { src: "мем4Дар.jpg", text: "от Дариши" },
    { src: "мем5Дар.jpg", text: "от Дариши" },
    { src: "мем6Дар.jpg", text: "от Дариши" },
    { src: "мем7Дар.jpg", text: "от Дариши" }
];

const CLOUD_SIZE_FACTOR = 0.55; 
// === СКОРОСТЬ ВЕРНУЛ НА 1.7 ===
const CLOUD_SPEED = 1.7;        
const GAP_BETWEEN_CLOUDS = 20; 

// --- ГРАФИКА ---
let W, H;
const canvas = document.getElementById('mainCanvas');
const ctx = canvas.getContext('2d');

function resize() { W = window.innerWidth; H = window.innerHeight; canvas.width = W; canvas.height = H; }
window.addEventListener('resize', resize);
resize();

// === КЛАСС ОБЛАКА ===
class PhotoCloud {
    constructor(data, startX, startY) {
        this.img = data.img;
        this.text = data.text;
        this.x = startX;
        this.y = startY;
        this.speed = CLOUD_SPEED;

        const baseSize = Math.min(W, H) * CLOUD_SIZE_FACTOR; 
        let imgW = baseSize;
        let imgH = baseSize * 0.7;
        
        if (this.img && this.img.complete && this.img.naturalWidth > 0) {
            const ratio = this.img.naturalWidth / this.img.naturalHeight;
            const maxDim = baseSize * 1.2;
            if (ratio > 1) { imgW = Math.min(maxDim, baseSize * 1.5); imgH = imgW / ratio; } 
            else { imgH = Math.min(maxDim, baseSize * 1.2); imgW = imgH * ratio; }
        }
        this.photoW = imgW;
        this.photoH = imgH;

        ctx.font = `bold ${Math.max(16, Math.floor(imgW * 0.08))}px Arial`;
        const textMetrics = ctx.measureText(this.text);
        const textWidth = textMetrics.width;
        const contentWidth = Math.max(imgW, textWidth);

        this.paddingX = baseSize * 0.15; 
        this.paddingY = baseSize * 0.15;
        this.textHeight = baseSize * 0.1;

        this.totalW = contentWidth + this.paddingX * 2;
        this.totalH = imgH + this.textHeight + this.paddingY * 2;
        this.width = this.totalW; 

        this.blobs = [];
        this.blobs.push({x: 0, y: 0, r: Math.max(this.totalW, this.totalH) * 0.5});
        
        const hw = this.totalW / 2;
        const hh = this.totalH / 2;
        const cornerR = this.totalH * 0.4;
        
        this.blobs.push({x: -hw, y: -hh*0.5, r: cornerR});
        this.blobs.push({x: hw, y: -hh*0.5, r: cornerR});
        this.blobs.push({x: -hw, y: hh*0.5, r: cornerR});
        this.blobs.push({x: hw, y: hh*0.5, r: cornerR});
        this.blobs.push({x: 0, y: -hh*0.8, r: this.totalW*0.3}); 
        this.blobs.push({x: 0, y: hh*0.8, r: this.totalW*0.3});  

        this.visualHalfWidth = hw + cornerR; 
    }

    draw() {
        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.beginPath();
        const r = 40; 
        const hw = this.totalW / 2;
        const hh = this.totalH / 2;
        ctx.roundRect(-hw, -hh, this.totalW, this.totalH, r);
        
        this.blobs.forEach(b => {
            ctx.moveTo(b.x + b.r, b.y);
            ctx.arc(b.x, b.y, b.r, 0, Math.PI * 2);
        });

        ctx.shadowColor = 'rgba(255, 255, 255, 0.9)'; 
        ctx.shadowBlur = 30; 
        ctx.fillStyle = '#FFFFFF'; 
        ctx.fill();
        ctx.shadowColor = 'transparent'; ctx.shadowBlur = 0;

        if (this.text) {
            ctx.fillStyle = "#333"; 
            const fontSize = Math.max(16, Math.floor(this.photoW * 0.08));
            ctx.font = `bold ${fontSize}px Arial`;
            ctx.textAlign = "center"; 
            ctx.textBaseline = "bottom";
            ctx.fillText(this.text, 0, -this.photoH / 2 - 10);
        }

        if (this.img && this.img.complete && this.img.naturalWidth > 0) {
            ctx.drawImage(this.img, -this.photoW/2, -this.photoH/2 + (this.textHeight/2), this.photoW, this.photoH);
            ctx.strokeStyle = "rgba(200,200,200,0.5)"; ctx.lineWidth = 1;
            ctx.strokeRect(-this.photoW/2, -this.photoH/2 + (this.textHeight/2), this.photoW, this.photoH);
        } else { ctx.fillStyle = "#eee"; ctx.fillRect(-this.photoW/2, -this.photoH/2, this.photoW, this.photoH); }
        ctx.restore();
    }
    update() { this.x += this.speed; }
}

let loadedContent = [];
cloudContent.forEach(item => {
    const img = new Image();
    img.src = item.src;
    loadedContent.push({ img: img, text: item.text });
});

let stars = [];
let snowflakes = [];
let plane = { x: -400, y: H * 0.25, speed: 5, wobble: 0, finished: false };
let clouds = []; 
let activePhotoClouds = []; 
let cloudsSpawned = false;

let mergeStarted = false, mergeStartTime = 0;
let flashActive = false, flashStartTime = 0;
let bigStarMode = false, bigStarStart = 0;
let afterFall = false;
let groundFlashActive = false, groundFlashStart = 0;
let transitionedToMorning = false;
let isEnding = false;
let fadeOpacity = 0;
let videoTriggered = false;
let currentSongIndex = 0;
let globalStartTime = 0;

const center = { x: W/2, y: H*0.19 };

function lerp(a, b, t) { return a + (b - a) * t; }
function ease(t) { return t < .5 ? 2 * t * t : -1 + (4 - 2 * t) * t; }

function startCelebration() {
    openFullscreen();
    const btn = document.getElementById('startBtn');
    btn.disabled = true;
    btn.innerText = "Загрузка..."; btn.style.background = "#555";
    const audio = document.getElementById('bgMusic');
    audio.src = musicPlaylist[0];
    audio.volume = 0.5;

    let playPromise = audio.play();
    if (playPromise !== undefined) {
        playPromise.then(_ => {
            document.getElementById('startScreen').style.display = 'none';
            resize();
            stars = createStars();
            initClouds();
            generateSnowflakes();
            globalStartTime = Date.now();
            startAppearSequence();
            animate();
            audio.onended = playNextTrack;
        }).catch(error => {
            console.log("Play failed:", error);
            document.getElementById('startScreen').style.display = 'none';
            globalStartTime = Date.now();
            animate();
        });
    }
}

function playNextTrack() {
    if (isEnding) return;
    currentSongIndex++;
    if (currentSongIndex >= musicPlaylist.length) currentSongIndex = 0;
    const audio = document.getElementById('bgMusic');
    audio.src = musicPlaylist[currentSongIndex];
    audio.play();
    audio.onended = playNextTrack;
}

function openFullscreen() {
    const elem = document.documentElement;
    if (elem.requestFullscreen) elem.requestFullscreen().catch(e=>{});
    else if (elem.webkitRequestFullscreen) elem.webkitRequestFullscreen();
}

function launchFinalVideo() {
    const vid = document.getElementById('finalVideo');
    document.getElementById('endMessage').style.display = 'none';
    document.getElementById('mainCanvas').style.display = 'none';
    const audio = document.getElementById('bgMusic');
    audio.pause();
    vid.style.display = 'block';
    vid.play().catch(e => {
        document.getElementById('errorLog').style.display = 'block';
        document.getElementById('errorLog').innerHTML += "Видео не запускается. Проверьте имя файла video.mp4";
    });
}

// === ГЕОМЕТРИЧЕСКИЙ СТРЕЛЕЦ (13 Звезд) ===
const sagittariusCoords = [
    // 1. СТРЕЛА (7 звезд) - Диагональ
    {x: 0.20, y: 0.80}, // 0. Хвост
    {x: 0.30, y: 0.70}, // 1
    {x: 0.40, y: 0.60}, // 2
    {x: 0.50, y: 0.50}, // 3. Центр пересечения
    {x: 0.60, y: 0.40}, // 4
    {x: 0.70, y: 0.30}, // 5
    {x: 0.80, y: 0.20}, // 6. Острие

    // 2. НАКОНЕЧНИК (2 звезды) - Галочка
    {x: 0.70, y: 0.20}, // 7. Верхний ус
    {x: 0.80, y: 0.30}, // 8. Нижний ус

    // 3. ЛУК (4 звезды) - Перпендикулярная линия
    {x: 0.20, y: 0.20}, // 9. Верхний конец лука
    {x: 0.35, y: 0.35}, // 10.
    {x: 0.65, y: 0.65}, // 11.
    {x: 0.80, y: 0.80}  // 12. Нижний конец лука
];

// Пары линий (соединяем только логически)
const constLines = [
    // Древко стрелы
    [0,1], [1,2], [2,3], [3,4], [4,5], [5,6],
    // Наконечник
    [6,7], [6,8],
    // Лук (проходит через центр 3)
    [9,10], [10,3], [3,11], [11,12]
];

function createStars() {
    let arr = [];
    for (let i=0; i<13; i++) {
        let pos = sagittariusCoords[i];
        arr.push({ 
            sx: pos.x * W, 
            sy: pos.y * H, 
            size: 13 + Math.random()*6, 
            state: 'hidden', appearStart: 0, flyStart: 0, mergeStart: 0,
            angle: 0, 
            spinSpeed: (Math.random() > 0.5 ? 1 : -1) * (0.05 + Math.random() * 0.05),
            currentOpacity: 0
        });
    }
    return arr;
}

function generateSnowflakes() { snowflakes=[]; for(let i=0;i<65;i++) snowflakes.push({x: Math.random()*W, y: Math.random()*H, r: 1.35+Math.random()*1.7, a: 0.42+Math.random()*0.42}); }
function initClouds() { clouds = []; for(let i=0; i<6; i++) clouds.push({x: Math.random()*W, y: Math.random()*(H*0.5), size: 0.4+Math.random()*0.4, speed: 0.2+Math.random()*0.3}); }

// === ТАЙМИНГ ===
const APPEAR_INTERVAL = 350; 
const MERGE_DELAY = 6640; 

function startAppearSequence() {
    for (let i=0; i<stars.length; i++) {
        stars[i].appearStart = globalStartTime + i * APPEAR_INTERVAL;
        stars[i].state = "hidden";
    }
    setTimeout(() => moveAllToCenter(), MERGE_DELAY);
}

function moveAllToCenter() { 
    for (let star of stars) { 
        star.state = "flying"; 
        star.flyStart = Date.now(); 
    } 
}

function startMerge() { if (!mergeStarted) { mergeStarted=true; mergeStartTime=Date.now(); flashActive=true; flashStartTime=mergeStartTime; for(let s of stars) {s.state="merging"; s.mergeStart=mergeStartTime;} } }
function startBigStar() { if (!bigStarMode) { bigStarMode = true; bigStarStart = Date.now(); } }
function startGroundFlash() { groundFlashActive = true; groundFlashStart = Date.now(); }

function drawStarShape(x, y, r, color, opacity=1, shadow=12, rotation=0) {
    ctx.save(); ctx.globalAlpha = opacity; ctx.translate(x, y); 
    ctx.rotate(rotation); 
    ctx.beginPath();
    for (let i=0; i<5; i++) { ctx.lineTo(r*Math.cos(-Math.PI/2+i*2*Math.PI/5), r*Math.sin(-Math.PI/2+i*2*Math.PI/5)); ctx.lineTo(r/2*Math.cos(-Math.PI/2+(i*2+1)*Math.PI/5), r/2*Math.sin(-Math.PI/2+(i*2+1)*Math.PI/5)); }
    ctx.closePath(); ctx.fillStyle = color; ctx.shadowColor = color; ctx.shadowBlur = shadow; ctx.fill(); ctx.restore();
}

function drawConstellationLines() {
    let timeSinceStart = Date.now() - globalStartTime;
    let fadeStart = MERGE_DELAY - 500;
    
    let globalLineAlpha = 1;
    if (timeSinceStart > fadeStart) {
        globalLineAlpha = 1 - (timeSinceStart - fadeStart) / 500;
        if (globalLineAlpha < 0) globalLineAlpha = 0;
    }
    if (globalLineAlpha <= 0) return;

    ctx.save();
    ctx.lineWidth = 2;
    ctx.strokeStyle = 'rgba(255, 215, 0, 0.6)'; 
    
    constLines.forEach(pair => {
        let s1 = stars[pair[0]];
        let s2 = stars[pair[1]];
        if (s1.currentOpacity > 0.1 && s2.currentOpacity > 0.1) {
            let lineAlpha = Math.min(s1.currentOpacity, s2.currentOpacity) * globalLineAlpha;
            ctx.globalAlpha = lineAlpha;
            ctx.beginPath();
            ctx.moveTo(s1.sx, s1.sy);
            ctx.lineTo(s2.sx, s2.sy);
            ctx.stroke();
        }
    });
    ctx.restore();
}

function drawWinterBackground() {
    let grad = ctx.createLinearGradient(0,0,0,H); grad.addColorStop(0,'#EAF0FA'); grad.addColorStop(0.5,'#c5deee'); grad.addColorStop(1,'#fbeff3');
    ctx.fillStyle=grad; ctx.fillRect(0,0,W,H);
    let sunX = W*0.86, sunY = H*0.14, sunR = Math.min(W,H)/8;
    let sunGrad = ctx.createRadialGradient(sunX, sunY, 0, sunX, sunY, sunR*1.15); sunGrad.addColorStop(0, 'rgba(255,245,220,1)'); sunGrad.addColorStop(1, 'rgba(255,236,200,0)');
    ctx.save(); ctx.globalAlpha = 0.96; ctx.beginPath(); ctx.arc(sunX, sunY, sunR*1.1, 0, 2*Math.PI); ctx.fillStyle = sunGrad; ctx.shadowColor = 'rgba(255,233,180,0.35)'; ctx.shadowBlur = 38; ctx.fill(); ctx.restore();
}

// === САМОЛЕТ БЕЗ ПРОПЕЛЛЕРА ===
function drawPlaneVisuals(x, y) {
    ctx.save(); ctx.translate(x, y); const scale = Math.min(W, H) / 1000; ctx.scale(scale * 1.5, scale * 1.5); 
    
    ctx.fillStyle = 'rgba(0,0,0,0.1)'; ctx.beginPath(); ctx.ellipse(0, 20, 60, 15, 0, 0, Math.PI*2); ctx.fill();
    ctx.fillStyle = '#FFFFFF'; ctx.beginPath(); ctx.ellipse(0, 0, 60, 15, 0, 0, Math.PI*2); ctx.fill();
    ctx.strokeStyle = '#999'; ctx.lineWidth = 1; ctx.stroke();
    ctx.fillStyle = '#CC0000'; ctx.beginPath(); ctx.moveTo(-40, -5); ctx.lineTo(-60, -25); ctx.lineTo(-55, -5); ctx.fill();
    ctx.fillStyle = '#DDDDDD'; ctx.beginPath(); ctx.moveTo(10, 5); ctx.lineTo(-10, 25); ctx.lineTo(20, 25); ctx.fill();
    
    // Нос
    ctx.fillStyle = '#87CEEB'; ctx.beginPath(); ctx.ellipse(15, -8, 10, 6, 0, 0, Math.PI*2); ctx.fill(); 
    
    ctx.restore();
}

function drawBanner(px, py) {
    const text = "С ДНЕМ РОЖДЕНИЯ!"; const scale = Math.min(W, H) / 1000; const finalScale = scale * 1.5;
    ctx.save(); ctx.font = `bold ${24 * finalScale}px Arial`; const textMetrics = ctx.measureText(text); const bannerWidth = textMetrics.width + (40 * finalScale); const bannerHeight = 40 * finalScale;
    const tailX = px - (60 * finalScale); const ropeLength = 50 * finalScale; const bannerStartX = tailX - ropeLength;
    ctx.beginPath(); ctx.moveTo(tailX, py); ctx.quadraticCurveTo(tailX - ropeLength/2, py + (10*finalScale), bannerStartX, py); ctx.strokeStyle = '#555'; ctx.lineWidth = 2; ctx.stroke();
    ctx.fillStyle = '#FFF8DC'; ctx.strokeStyle = '#DAA520'; ctx.lineWidth = 1;
    ctx.beginPath(); const time = Date.now() / 200;
    for (let i = 0; i <= bannerWidth; i += 5) { const yOffset = Math.sin((i / 20) + time) * (5 * finalScale); const bx = bannerStartX - i; const by = py - bannerHeight/2 + yOffset; if (i === 0) ctx.moveTo(bx, by); else ctx.lineTo(bx, by); }
    const lastYOffsetTop = Math.sin((bannerWidth / 20) + time) * (5 * finalScale); ctx.lineTo(bannerStartX - bannerWidth, py + bannerHeight/2 + lastYOffsetTop);
    for (let i = bannerWidth; i >= 0; i -= 5) { const yOffset = Math.sin((i / 20) + time) * (5 * finalScale); const bx = bannerStartX - i; const by = py + bannerHeight/2 + yOffset; ctx.lineTo(bx, by); }
    ctx.closePath(); ctx.fill(); ctx.stroke();
    ctx.fillStyle = '#FF4500'; ctx.textAlign = "center"; ctx.textBaseline = "middle"; const centerWave = Math.sin((bannerWidth/2 / 20) + time) * (5 * finalScale); ctx.fillText(text, bannerStartX - bannerWidth/2, py + centerWave); ctx.restore();
}

function drawFullFlash(opacity) { 
    ctx.save(); 
    ctx.globalAlpha = opacity; 
    ctx.fillStyle = 'rgba(255, 250, 210, 1)'; 
    ctx.fillRect(0,0,W,H); 
    ctx.restore(); 
}

// === АНИМАЦИЯ ===
function animate() {
    center.x = W/2; 
    let now = Date.now(); 
    let timeSinceStart = now - globalStartTime;

    if (!transitionedToMorning) { 
        ctx.fillStyle = '#000'; ctx.fillRect(0,0,W,H); 
    } else {
        drawWinterBackground(); 
    }

    if (!transitionedToMorning) {
        drawConstellationLines();

        let allInCenter = stars.every(s => s.state==="inCenter") && !mergeStarted;
        
        for(let i=0; i<stars.length; i++) {
            let star = stars[i];
            
            if (star.state === 'hidden' && now >= star.appearStart) {
                star.state = "appearing";
            }
            if (star.state === "appearing") {
                if (star.currentOpacity < 1) star.currentOpacity += 0.05;
                if (star.currentOpacity >= 1) star.state = "visible";
            }

            let t=0;
            if(star.state === "flying") { star.angle += 0.15; }

            if(star.state==="appearing" || star.state==="visible") t=1; 
            else if(star.state==="flying") { 
                t = Math.min((now-star.flyStart)/1000, 1); 
                var x=lerp(star.sx,center.x,t), y=lerp(star.sy,center.y,t); 
                drawStarShape(x,y,star.size,'gold',1, 12, star.angle); 
                if(t===1)star.state="inCenter"; continue; 
            }
            else if(star.state==="inCenter") { drawStarShape(center.x,center.y,star.size,'gold',1, 12, 0); continue;} 
            else if(star.state==="merging") { let mt = Math.min((now-star.mergeStart)/700,1); drawStarShape(center.x,center.y,star.size,'gold',1-mt, 12, 0); continue;}
            
            if (star.state !== 'hidden') {
                let drawAngle = (star.state === "flying") ? star.angle : 0;
                drawStarShape(star.sx, star.sy, star.size, 'gold', star.currentOpacity, 12, drawAngle);
            }
        }

        if (allInCenter) startMerge();
        if (mergeStarted && !bigStarMode) { let t = Math.min((now-mergeStartTime)/700,1); drawStarShape(center.x, center.y, Math.max(W,H)/26, 'gold', t); if (t === 1) setTimeout(() => startBigStar(), 350); }
        if (flashActive) { let t = (now-flashStartTime)/750; if (t<1) { ctx.save(); ctx.globalAlpha = 0.36*(1-t); ctx.fillStyle = 'rgba(255, 250, 210, 1)'; ctx.fillRect(0,0,W,H); ctx.restore(); ctx.save(); ctx.globalAlpha = 0.61*(1-t); var grad = ctx.createRadialGradient(center.x, center.y, 0, center.x, center.y, Math.max(W,H)*0.7); grad.addColorStop(0, 'rgba(255, 235, 100, 1)'); grad.addColorStop(1, 'rgba(255, 202, 84, 0)'); ctx.beginPath(); ctx.arc(center.x, center.y, Math.max(W,H)*0.76, 0, 2*Math.PI); ctx.fillStyle = grad; ctx.fill(); ctx.restore(); } else flashActive = false; }
        
        if (bigStarMode && !afterFall) { 
            let t = Math.min((now-bigStarStart)/3500, 1); let curve = ease(t); 
            let y = lerp(center.y, H * 0.85, curve); 
            let x = lerp(center.x, center.x + W*0.19, curve*0.82 + t*0.18); 
            let r = lerp(Math.max(W,H)/26, Math.max(W,H)/64, t); let rot = t*2*Math.PI*1.07; 
            for(let i=0; i<20 && t > 0; i++){ let trailT = t - i*0.035; if(trailT<=0)continue; let trailCurve = ease(trailT); let tx = lerp(center.x, center.x+W*0.19, trailCurve*0.82 + trailT*0.18); let ty = lerp(center.y, H * 0.85, trailCurve); 
                drawStarShape(tx, ty, r*0.77, 'gold', 0.1*(1-i/19)*(1-trailT), 12, rot-i*0.115);
            } 
            if (t < 1) drawStarShape(x, y, r, 'gold', lerp(1,0.56,t), 12, rot); if (t === 1 && !afterFall) { afterFall = true; setTimeout(()=>startGroundFlash(), 60); } 
        }
    }

    if (groundFlashActive || transitionedToMorning) {
        let t = (now-groundFlashStart)/1700;
        
        if (transitionedToMorning) {
            clouds.forEach(c => { c.x -= c.speed; if (c.x < -100) { c.x = W + 100; c.y = Math.random() * (H / 2); } ctx.fillStyle = 'rgba(255, 255, 255, 0.6)'; ctx.beginPath(); ctx.arc(c.x, c.y, 30*c.size, 0, Math.PI*2); ctx.arc(c.x+25*c.size, c.y-15*c.size, 35*c.size, 0, Math.PI*2); ctx.arc(c.x+50*c.size, c.y, 30*c.size, 0, Math.PI*2); ctx.fill(); });
            
            if (!plane.finished) { 
                plane.x += plane.speed; plane.wobble = Math.sin(Date.now() / 500) * 10; 
                drawPlaneVisuals(plane.x, plane.y + plane.wobble); 
                drawBanner(plane.x, plane.y + plane.wobble); 
                if (plane.x > W + 2000) plane.finished = true; 
            }

            if (plane.x > W + 100) {
                if (!cloudsSpawned) {
                    cloudsSpawned = true; 
                    
                    let firstCloud = new PhotoCloud(loadedContent[0], 0, 0);
                    let currentX = - (firstCloud.visualHalfWidth * 2 * 0.85 + 50); 

                    for(let i=0; i<loadedContent.length; i++) { 
                        let tempCloud = new PhotoCloud(loadedContent[i], 0, 0);
                        let visualWidth = tempCloud.visualHalfWidth * 2; 
                        
                        let cX = currentX;
                        let cY; 
                        let offset = H * 0.12; 
                        if (i % 3 === 0) cY = H/2 - offset; else if (i % 3 === 1) cY = H/2 + offset; else cY = H/2; 
                        cY += (Math.random() * 20 - 10); 
                        
                        activePhotoClouds.push(new PhotoCloud(loadedContent[i], cX, cY));
                        
                        currentX -= (visualWidth + GAP_BETWEEN_CLOUDS);
                    }
                }
                for (let i = 0; i < activePhotoClouds.length; i++) {
                    let pc = activePhotoClouds[i]; pc.update(); pc.draw();
                    if (pc.x > W + pc.width + 100) { activePhotoClouds.splice(i, 1); i--; }
                }
                if (cloudsSpawned && activePhotoClouds.length === 0 && !isEnding) {
                    isEnding = true;
                    document.getElementById('endMessage').style.opacity = 1;
                }
            }
            for(let s of snowflakes) { s.y += 0.5; if(s.y > H) s.y = -10; ctx.save(); ctx.globalAlpha = s.a; ctx.beginPath(); ctx.arc(s.x,s.y,s.r,0,2*Math.PI); ctx.fillStyle = "#fff"; ctx.shadowColor = "#e0e6ff"; ctx.shadowBlur = 7+s.r*2; ctx.fill(); ctx.restore(); }
        }

        if(t<=1 && groundFlashActive){ 
            let flashOp = 1.09*(1-Math.pow(t,2.3)); 
            if (flashOp > 0) drawFullFlash(flashOp);
        }
        if (t>0.48 && !transitionedToMorning) { transitionedToMorning = true; generateSnowflakes(); initClouds(); }
    }

    if (isEnding) {
        fadeOpacity += 0.005; 
        if (fadeOpacity > 1) fadeOpacity = 1;
        ctx.fillStyle = `rgba(0, 0, 0, ${fadeOpacity})`;
        ctx.fillRect(0, 0, W, H);
        const audio = document.getElementById('bgMusic');
        if (audio.volume > 0.003) { let newVol = audio.volume - 0.003; audio.volume = newVol; } else { audio.volume = 0; }
        if (fadeOpacity >= 1 && !videoTriggered) { videoTriggered = true; setTimeout(launchFinalVideo, 3000); }
    }

    requestAnimationFrame(animate);
}
</script>
</body>
</html>
